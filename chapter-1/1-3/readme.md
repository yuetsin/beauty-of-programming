# 1.3 一摞烙饼的排序

## ★★★

星期五的晚上，一帮同事在希格玛大厦附近的「硬盘酒吧」多喝了几杯。程序员喝了几杯之後谈什么呢？自然是算法问题。

有个同事说：「我以前在餐馆打工，顾客进场点非常多的烙饼。店里的饼大小不一，我习惯在到达顾客饭桌前，把一摞饼按照大小次序摆好——小的在上面，大的在下面。由于我一只手托着盘子，只好用另一只手，一次抓住最上面的几块饼，把他们上下颠倒个个儿，反复几次之後，这摞烙饼就排好序了。」

「我後来想，这实际上是个有趣的排序问题：假设有 $n$ 块大小不一的烙饼，那最少要翻几次，才能达到最後大小有序的结果呢？」

你能否写出一个程序，对于 $n$ 块大小不一的烙饼，输出最优化的翻饼过程呢？

## 解

这题跟普通的排序题都不一样…因为我们可以做的操作只有，`reverse(list[i:])` 这一件事；即，把从某一区间到尾部的这部分翻转。不能把饼子抽出来、不能交换任意两块饼。

在这种情况下，我们的排序该怎么进行呢？

不妨先设我们的饼子列表 `Cake` 是 shuffle 过的 `list(range(N)`。这样，当值为 `i` 的饼子到达 `i` 索引位置的时候，就可以认定为排序好了。

### Recursive Solution

#### Intuition

首先，可以观察到这道题是可以自底向上的。因为我们的「翻饼子」操作一定是涉及到 `list[i:]`，即饼摞的靠上一部分的；

所以，如果面积大于一定值的  `j`  个饼子都排好序了（已经好好地分布到 `Cake[:j]` 里了），那么就无需再管他们了，可以认为问题简化到了饼数量为 `N - j` 的地步。

最后，问题一定会简化到轻易的 `N = 2`，也就是只需要 0 次或 1 次翻转就能使他们有序。

这个 Recursive 是成立的。

#### Put cake `i` in place

因为上面的递归最终可以解，那么我们要做的就是通过一般的操作，把 `Cake(N)` 问题简化到 `Cake(N - 1)` 问题。也就是，把当前最大的那张饼（记为 `M`）放置到位。

分情况讨论：

* 假如 `M` 当前位于饼摞的底部（数组的头部），那么无需进行排序，直接推到 `N - 1`；

* 假如 `M` 当前位于饼摞的顶部（数组的尾部），那么只需要翻转整个饼摞，`M` 就被埋到了饼摞的底部，推到了 `N - 1`。

* 假如当前 `M` 位于索引 `k` 位置，其中 `k` 不是 0，也不是 `N - 1`。

我们的目的是把 `C[k]` 放到 `C[0]` 位置，而不考虑其他所有数字。在每个循环里都只保证最大的那块饼到位。

很容易就能想出办法：

1. 翻转 `Cake[k:]`，这样 `Cake[k]` 就到了数组尾部，也就是「饼摞」的顶部。

2. 翻转整个 `Cake`，这样第一步中在顶部的 `Cake[k]` 就被埋到了底部。

以上的讨论就覆盖了全部的情况。可以看到，由大到小地，每一次置位一张饼，需要的翻转次数可能是 0 次、1 次、或 2 次。

因此可以知道，对于 `N` 张饼组成的饼摞，我们需要的最多翻转数不会超过 `2 * (N - 1)`（因为最後两张饼不需要走讨论流程。）。

#### Optimization

上面的讨论只是证明了「通过翻转来排序饼」是可以实现的，而且给出了一个（非常粗的）上界。

实际的方案当然可以从各种方向上优化：比如，如果烙饼摞中的一些部分是已经排好序的，那么我们应该倾向于不去破坏那些有序性，而是优先把较小一些的烙饼摞给摞好，然后再把他们整体翻过来。

但是，这些都只是停留在「直觉」上的感觉。实际上计算机能解决的事情，还是只能靠穷举。

#### Exhaustion

给出 `N` 个饼组成的饼摞。

首先，我们没必要去翻动那些已经到位的、位于底部的大饼。所以我们要翻动的只是靠上的、较小的、顺序还没好的饼，记其数量为 `k`。

那么，我们一共有 `k - 1` 种翻动饼的选择；这可以作为一个 DFS。

假如我们所有的饼子都已经排序好了，或者当前的翻动次数已经超过了上界 $2 \times (N - 1)$，那么可以直接退出了。

## Applied Scene

看起来这题没有什么应用场景——对一般的数组而言，翻转 `k` 个数字所需要耗费的时间一般都很高。

然而，对于无向图而言，我们可以用 $O(1)$ 的时间复杂度来实现上述的「翻饼」操作。

或许这算是一个应用场景吧。
